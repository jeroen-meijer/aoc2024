use core::panic;
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;
use std::time::Duration;

use stopwatch::Stopwatch;

mod prelude;

// Macro to generate get_assignment calls (must be defined before the include)
macro_rules! include_assignments {
    ($($day:literal),* $(,)?) => {
        /// Returns all registered assignments.
        ///
        /// Automatically discovers and loads all assignment modules from
        /// `assignment_*.rs` files. The assignments are sorted by day number.
        ///
        /// # Returns
        ///
        /// A vector of all `Assignment` instances, sorted by day number.
        ///
        /// # Panics
        ///
        /// Panics if multiple assignments have the same day number.
        pub fn get_assignments() -> Vec<Assignment> {
            let assignments = vec![
                $(
                    paste::paste! {
                        [<assignment_ $day>]::get_assignment()
                    }
                ),*
            ];

            let assignments_by_day =
                assignments
                    .iter()
                    .fold(HashMap::<u32, Vec<&Assignment>>::new(), |mut acc, cur| {
                        acc.entry(cur.day).or_default().push(cur);
                        acc
                    });
            for (day, assignments) in assignments_by_day {
                if assignments.len() > 1 {
                    let assignment_names = assignments
                        .iter()
                        .map(|a| a.description)
                        .collect::<Vec<_>>();
                    panic!(
                        "Found duplicate assignment day number {} for assignments: {:?}",
                        day, assignment_names
                    );
                }
            }

            assignments
        }
    };
}

// Include all assignment modules - auto-generated by build.rs
include!(concat!(env!("OUT_DIR"), "/assignments.rs"));

/// Represents the answer to an Advent of Code puzzle.
///
/// Answers can be either integers (for numeric solutions) or strings
/// (for text-based solutions). The enum implements `From` for common
/// integer types and strings, making it easy to convert results.
///
/// # Examples
///
/// ```
/// use assignments::Answer;
///
/// let int_answer: Answer = 42.into();
/// let str_answer: Answer = "hello".into();
/// ```
#[derive(PartialEq, Clone)]
pub enum Answer {
    /// An integer answer (e.g., a count, sum, or numeric result)
    Integer(u64),
    /// A string answer (e.g., a password, message, or text result)
    String(String),
}

impl ToString for Answer {
    fn to_string(&self) -> String {
        match self {
            Answer::Integer(i) => i.to_string(),
            Answer::String(s) => format!("\"{s}\""),
        }
    }
}

impl From<u64> for Answer {
    fn from(value: u64) -> Self {
        Answer::Integer(value)
    }
}

impl From<u32> for Answer {
    fn from(value: u32) -> Self {
        Answer::Integer(value.into())
    }
}

impl From<i32> for Answer {
    fn from(value: i32) -> Self {
        if value < 0 {
            panic!("Integer value has to be positive.");
        }
        Answer::Integer(value as u64)
    }
}

impl From<String> for Answer {
    fn from(value: String) -> Self {
        Answer::String(value)
    }
}

impl From<&str> for Answer {
    fn from(value: &str) -> Self {
        value.to_owned().into()
    }
}

impl From<usize> for Answer {
    fn from(value: usize) -> Self {
        Answer::Integer(value as u64)
    }
}

/// Groups test cases for an assignment's four scenarios.
///
/// Each assignment has four test cases:
/// - `example_day_1`: Example input for part 1 (optional)
/// - `day1`: Real input for part 1 (from assignment_N.txt file)
/// - `example_day_2`: Example input for part 2 (optional)
/// - `day2`: Real input for part 2 (from assignment_N.txt file)
///
/// The generic type `T` allows this to hold either `TestCase` (input)
/// or `TestCaseOutput` (results).
pub struct TestCaseGroup<T> {
    /// Example input and expected answer for part 1
    pub example_day_1: T,
    /// Real input and expected answer for part 1
    pub day1: T,
    /// Example input and expected answer for part 2
    pub example_day_2: T,
    /// Real input and expected answer for part 2
    pub day2: T,
}

/// Defines a single test case for an assignment.
///
/// Test cases specify the input data and expected answer for a particular
/// part of a puzzle. Example cases use inline strings, while real cases
/// read from `assignment_N.txt` files.
pub struct TestCase {
    /// Input data as a string. `None` means read from `assignment_N.txt`
    pub input: Option<&'static str>,
    /// Expected answer. `None` means no expected answer (for testing)
    pub expected: Option<Answer>,
    /// Which part of the puzzle this test case is for (1 or 2)
    pub part_number: u8,
    /// Whether this is an example case (true) or real input case (false)
    pub is_example: bool,
}

/// Results from running a test case.
///
/// Contains the actual output from running an assignment function,
/// along with timing information and comparison to expected results.
pub struct TestCaseOutput {
    /// The input data that was used (after processing)
    pub input: String,
    /// The expected answer (if provided)
    pub expected: Option<Answer>,
    /// The actual result from the assignment function, or an error message
    pub actual: Result<Option<Answer>, String>,
    /// How long the assignment took to run
    pub runtime: Duration,
}

impl TestCaseOutput {
    /// Determines the test case result status.
    ///
    /// Compares the actual result against the expected answer (if provided)
    /// and returns the appropriate `TestCaseResult`.
    ///
    /// # Returns
    ///
    /// - `Correct`: Actual matches expected
    /// - `Incorrect`: Actual doesn't match expected
    /// - `NoAnswer`: Function returned `None`
    /// - `Error`: Function returned an error
    /// - `Unknown`: No expected answer provided
    pub fn get_result(&self) -> TestCaseResult {
        match &self.actual {
            Ok(a) => match a {
                None => TestCaseResult::NoAnswer,
                Some(answer_value) => match &self.expected {
                    Some(expected_value) => {
                        if answer_value == expected_value {
                            TestCaseResult::Correct
                        } else {
                            TestCaseResult::Incorrect
                        }
                    }
                    None => TestCaseResult::Unknown,
                },
            },
            Err(_) => TestCaseResult::Error,
        }
    }
}

/// The result status of a test case execution.
///
/// Indicates whether the assignment function produced the correct answer,
/// an error occurred, or the result couldn't be validated.
pub enum TestCaseResult {
    /// The function returned `None` (no answer provided)
    NoAnswer,
    /// No expected answer was provided, so correctness is unknown
    Unknown,
    /// The actual answer matches the expected answer
    Correct,
    /// The actual answer doesn't match the expected answer
    Incorrect,
    /// An error occurred while running the assignment
    Error,
}

impl TestCaseResult {
    /// Returns `true` if the test case result is `Correct`.
    pub fn is_correct(&self) -> bool {
        matches!(self, TestCaseResult::Correct)
    }
}

/// Represents an Advent of Code assignment/puzzle.
///
/// An assignment contains all the test cases and the function to run
/// for solving the puzzle. Use `Assignment::new()` with `AssignmentOptions`
/// to create an assignment.
pub struct Assignment {
    /// The day number of the puzzle (0-indexed)
    pub day: u32,
    /// A description of the puzzle
    pub description: &'static str,
    /// The test cases for this assignment
    pub cases: TestCaseGroup<Option<TestCase>>,

    /// The function that solves the puzzle
    _f: InternalAssignmentCallback,
}

type InternalAssignmentCallback =
    fn(context: AssignmentRuntimeContext) -> Result<Option<Answer>, String>;

/// Configuration options for creating an `Assignment`.
///
/// Used with `Assignment::new()` to define a puzzle. All fields except
/// `day`, `description`, and `run` are optional.
///
/// # Examples
///
/// ```no_run
/// use assignments::{Assignment, AssignmentOptions};
///
/// Assignment::new(AssignmentOptions {
///     day: 1,
///     description: "My Puzzle",
///     run: my_solution_function,
///     example_input_day_1: Some("test input"),
///     answer_example_day_1: Some(42.into()),
///     answer_day_1: Some(100.into()),
///     example_input_day_2: None,
///     answer_example_day_2: None,
///     answer_day_2: None,
/// });
/// ```
pub struct AssignmentOptions {
    /// The day number (0-indexed)
    day: u32,
    /// Description of the puzzle
    description: &'static str,
    /// The function that solves the puzzle
    run: InternalAssignmentCallback,
    /// Example input for part 1 (optional)
    example_input_day_1: Option<&'static str>,
    /// Expected answer for example part 1 (optional)
    answer_example_day_1: Option<Answer>,
    /// Expected answer for real part 2 (optional)
    answer_day_2: Option<Answer>,
    /// Example input for part 2 (optional)
    example_input_day_2: Option<&'static str>,
    /// Expected answer for example part 2 (optional)
    answer_example_day_2: Option<Answer>,
    /// Expected answer for real part 1 (optional)
    answer_day_1: Option<Answer>,
}

/// Runtime context passed to assignment solution functions.
///
/// Provides the input data and metadata about which part of the puzzle
/// is being solved. This is the parameter type for assignment solution functions.
///
/// # Examples
///
/// ```no_run
/// use assignments::{AssignmentRuntimeContext, Answer};
///
/// fn solve(context: AssignmentRuntimeContext) -> Result<Option<Answer>, String> {
///     if context.part_number == 1 {
///         // Solve part 1
///     } else {
///         // Solve part 2
///     }
///     Ok(Some(42.into()))
/// }
/// ```
pub struct AssignmentRuntimeContext<'a> {
    /// The input lines from the puzzle file or example input
    pub data: &'a Vec<String>,
    /// Which part is being solved (1 or 2)
    pub part_number: u8,
    /// Whether this is an example case (`true`) or real input (`false`)
    pub is_example: bool,
    /// Whether logging is enabled (currently unused)
    pub logging_enabled: bool,
}

impl Assignment {
    /// Creates a new assignment from the given options.
    ///
    /// # Arguments
    ///
    /// * `options` - Configuration for the assignment including day, description,
    ///   solution function, and test cases
    ///
    /// # Returns
    ///
    /// A new `Assignment` instance ready to be run.
    pub fn new(options: AssignmentOptions) -> Assignment {
        return Assignment {
            day: options.day,
            description: options.description,
            cases: TestCaseGroup {
                example_day_1: options.example_input_day_1.and(Some(TestCase {
                    input: options.example_input_day_1,
                    expected: options.answer_example_day_1,
                    part_number: 1,
                    is_example: true,
                })),
                day1: Some(TestCase {
                    input: None,
                    expected: options.answer_day_1,
                    part_number: 1,
                    is_example: false,
                }),
                example_day_2: options.example_input_day_2.and(Some(TestCase {
                    input: options.example_input_day_2,
                    expected: options.answer_example_day_2,
                    part_number: 2,
                    is_example: true,
                })),
                day2: Some(TestCase {
                    input: None,
                    expected: options.answer_day_2,
                    part_number: 2,
                    is_example: false,
                }),
            },
            _f: options.run,
        };
    }

    /// Runs all test cases for this assignment.
    ///
    /// Executes the assignment function for each configured test case
    /// and returns the results. Test cases that require input files
    /// will be skipped if the file is missing.
    ///
    /// # Returns
    ///
    /// A `TestCaseGroup` containing the results for each test case.
    /// `None` values indicate the test case was skipped (e.g., missing file).
    pub fn run(&self) -> TestCaseGroup<Option<TestCaseOutput>> {
        TestCaseGroup {
            example_day_1: self
                .cases
                .example_day_1
                .as_ref()
                .and_then(|case| self._run_test_case(case)),
            day1: self
                .cases
                .day1
                .as_ref()
                .and_then(|case| self._run_test_case(case)),
            example_day_2: self
                .cases
                .example_day_2
                .as_ref()
                .and_then(|case| self._run_test_case(case)),
            day2: self
                .cases
                .day2
                .as_ref()
                .and_then(|case| self._run_test_case(case)),
        }
    }

    fn _run_test_case(&self, test_case: &TestCase) -> Option<TestCaseOutput> {
        let lines = match test_case.input {
            Some(i) => i.lines().map(|s| s.to_string()).collect::<Vec<_>>(),
            None => {
                let filename = format!("src/assignments/assignment_{}.txt", self.day);
                let lines = match _read_lines(&filename) {
                    Ok(lines) => lines,
                    Err(_) => return None,
                };
                lines.filter_map(Result::ok).collect::<Vec<_>>()
            }
        };
        let lines = lines
            .iter()
            .skip_while(|a| a.is_empty())
            .map(|a| a.to_string())
            .collect::<Vec<_>>();

        let expected = test_case.expected.clone();

        let mut stopwatch = Stopwatch::start_new();
        let actual = (self._f)(AssignmentRuntimeContext {
            data: &lines,
            part_number: test_case.part_number,
            is_example: test_case.is_example,
            logging_enabled: false,
        });
        let runtime = stopwatch.elapsed();
        stopwatch.stop();

        Some(TestCaseOutput {
            input: lines.join("\n"),
            expected,
            actual,
            runtime,
        })
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn _read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
